#include <stdint.h>
#include <stddef.h>

void to_hex(const uint8_t* b, size_t n, char* out) {
  static const char h[]="0123456789abcdef";
  for (size_t i=0;i<n;i++) { out[i*2]=h[b[i]>>4]; out[i*2+1]=h[b[i]&0xf]; }
  out[n*2]=0;
}
uint8_t hex_char(char c) {
  if(c>='0'&&c<='9')return c-'0'; if(c>='a'&&c<='f')return c-'a'+10;
  if(c>='A'&&c<='F')return c-'A'+10; return 0xff;
}
size_t from_hex(const char* h, uint8_t* out) {
  size_t j=0; for(;h[0]&&h[1];h+=2) { uint8_t a=hex_char(h[0]),b=hex_char(h[1]);
  if(a>15||b>15)break; out[j++]=a<<4|b; } return j;
}
uint32_t read_u32be(const uint8_t* p) { return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3]; }
void write_u32be(uint32_t v, uint8_t* p) { p[0]=v>>24;p[1]=v>>16;p[2]=v>>8;p[3]=v; }
uint32_t read_u32le(const uint8_t* p) { return p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24); }
void write_u32le(uint32_t v, uint8_t* p) { p[0]=v;p[1]=v>>8;p[2]=v>>16;p[3]=v>>24; }

void xor_inplace(uint8_t* a, const uint8_t* b, size_t n) { for(size_t i=0;i<n;i++) a[i]^=b[i]; }
void xor_buf(const uint8_t* a, const uint8_t* b, uint8_t* out, size_t n) { for(size_t i=0;i<n;i++) out[i]=a[i]^b[i]; }
uint32_t rotl32(uint32_t v, int n) { n&=31; return (v<<n)|(v>>(32-n)); }
uint32_t rotr32(uint32_t v, int n) { n&=31; return (v>>n)|(v<<(32-n)); }
uint32_t swap32(uint32_t v) { return ((v&0xff)<<24)|((v&0xff00)<<8)|((v&0xff0000)>>8)|((v&0xff000000)>>24); }
int get_bit(uint32_t v, int b) { return (v>>b)&1; }
uint32_t set_bit(uint32_t v, int b, int on) { return on? v|(1u<<b) : v&~(1u<<b); }

static const uint8_t vm[256]={0x13,0x4a,0xe0,0xcd,0xc5,0xe6,0x3a,0x62,0x8f,0x2a,0xa4,0x3c,0x23,0xe9,0x06,0xa2,0xe5,0x47,0x20,0x86,0xa8,0x92,0xdc,0xcc,0xc0,0xf6,0x15,0xa5,0x55,0x7e,0xae,0xea,0x64,0x87,0xdb,0xf9,0xc4,0x32,0xda,0x12,0x91,0x42,0x25,0x7d,0xf8,0x38,0xaa,0x58,0xfa,0x5e,0x70,0x01,0x95,0x68,0xbd,0xa1,0x2f,0xf3,0x6b,0x5a,0xb9,0x10,0xb2,0x0d,0xd1,0x84,0xc7,0x51,0x5d,0x8c,0xe7,0x04,0x3b,0x0c,0xca,0x79,0x35,0x8a,0xf5,0xb8,0xf1,0xac,0xad,0x52,0x2d,0x50,0x72,0x21,0x53,0xdf,0x37,0x71,0x80,0xc9,0x9a,0x9c,0x7b,0x57,0x45,0x7f,0x6a,0xbc,0x27,0xfe,0x7a,0x28,0x30,0xfc,0x8b,0xf0,0x73,0xee,0xd0,0x76,0x6e,0xd5,0x48,0xec,0xa6,0x4f,0x41,0x17,0xb7,0x82,0x63,0xc2,0xcb,0x67,0x6c,0xfb,0x3e,0xf4,0x02,0x44,0xce,0xef,0x1a,0x60,0x98,0xd3,0xff,0xed,0xde,0x90,0x56,0x24,0xcf,0xeb,0x54,0xa9,0x1e,0x69,0xab,0x89,0x18,0x00,0xb3,0x31,0x5f,0xc1,0x2c,0x8d,0x14,0x05,0x33,0xbb,0x1d,0xe8,0x4e,0x75,0x1f,0x1c,0x8e,0xd8,0xe2,0x29,0x9b,0x43,0xa0,0xa3,0x99,0xe4,0xf2,0x97,0x5b,0x74,0xb1,0x4d,0x22,0x3d,0x66,0x61,0x08,0xc8,0x16,0x0e,0x1b,0x4c,0x77,0x83,0xfd,0x0a,0xd7,0x2e,0x96,0x81,0xe1,0x78,0xb4,0x65,0x03,0xb6,0x2b,0x6d,0x94,0x93,0x5c,0x0b,0xb5,0x0f,0xb0,0x39,0x11,0x85,0x26,0xba,0xf7,0x07,0xbf,0xe3,0x9e,0x59,0x3f,0x09,0xd4,0xd6,0xaf,0x4b,0xa7,0xbe,0x19,0x49,0xc6,0x46,0x34,0xd2,0x88,0xdd,0x6f,0xc3,0x9d,0x9f,0x7c,0x40,0xd9,0x36};
static const uint8_t vm_inv[256]={0x9b,0x33,0x84,0xd2,0x47,0xa3,0x0e,0xe3,0xc0,0xe9,0xc9,0xd9,0x49,0x3f,0xc3,0xdb,0x3d,0xde,0x27,0x00,0xa2,0x1a,0xc2,0x79,0x9a,0xf0,0x88,0xc4,0xab,0xa6,0x96,0xaa,0x12,0x57,0xbc,0x0c,0x91,0x2a,0xe0,0x66,0x69,0xaf,0x09,0xd4,0xa0,0x54,0xcb,0x38,0x6a,0x9d,0x25,0xa4,0xf4,0x4c,0xff,0x5a,0x2d,0xdd,0x06,0x48,0x0b,0xbd,0x82,0xe8,0xfd,0x78,0x29,0xb1,0x85,0x62,0xf3,0x11,0x74,0xf1,0x01,0xed,0xc5,0xbb,0xa8,0x77,0x55,0x43,0x53,0x58,0x94,0x1c,0x90,0x61,0x2f,0xe7,0x3b,0xb8,0xd8,0x44,0x31,0x9e,0x89,0xbf,0x07,0x7c,0x20,0xd1,0xbe,0x7f,0x35,0x97,0x64,0x3a,0x80,0xd5,0x72,0xf8,0x32,0x5b,0x56,0x6e,0xb9,0xa9,0x71,0xc6,0xcf,0x4b,0x68,0x60,0xfc,0x2b,0x1d,0x63,0x5c,0xcd,0x7b,0xc7,0x41,0xdf,0x13,0x21,0xf6,0x99,0x4d,0x6c,0x45,0xa1,0xac,0x08,0x8f,0x28,0x15,0xd7,0xd6,0x34,0xcc,0xb7,0x8a,0xb4,0x5e,0xb0,0x5f,0xfa,0xe6,0xfb,0xb2,0x37,0x0f,0xb3,0x0a,0x1b,0x76,0xee,0x14,0x95,0x2e,0x98,0x51,0x52,0x1e,0xec,0xdc,0xba,0x3e,0x9c,0xd0,0xda,0xd3,0x7a,0x4f,0x3c,0xe1,0xa5,0x65,0x36,0xef,0xe4,0x18,0x9f,0x7d,0xf9,0x24,0x04,0xf2,0x42,0xc1,0x5d,0x4a,0x7e,0x17,0x03,0x86,0x92,0x70,0x40,0xf5,0x8b,0xea,0x73,0xeb,0xca,0xad,0xfe,0x26,0x22,0x16,0xf7,0x8e,0x59,0x02,0xce,0xae,0xe5,0xb5,0x10,0x05,0x46,0xa7,0x0d,0x1f,0x93,0x75,0x8d,0x6f,0x87,0x6d,0x50,0xb6,0x39,0x83,0x4e,0x19,0xe2,0x2c,0x23,0x30,0x81,0x6b,0xc8,0x67,0x8c};
void vm_apply(uint8_t* b, size_t n) { for (size_t i = 0; i < n; i++) b[i] = vm[b[i]]; }
void vm_apply_inv(uint8_t* b, size_t n) { for (size_t i = 0; i < n; i++) b[i] = vm_inv[b[i]]; }
const uint8_t* vm_get(void) { return vm; }
const uint8_t* vm_get_inv(void) { return vm_inv; }

static uint32_t crc32_table[256]; static int crc_init;
void crc32_init(void) {
  if(crc_init) return; crc_init=1;
  for(uint32_t i=0;i<256;i++) { uint32_t c=i;
  for(int k=0;k<8;k++) c=(c&1)?(c>>1)^0xedb88320:c>>1; crc32_table[i]=c; }
}
uint32_t crc32(const uint8_t* d, size_t n) {
  crc32_init(); uint32_t crc=0xffffffff;
  for(size_t i=0;i<n;i++) crc=(crc>>8)^crc32_table[(crc^d[i])&0xff];
  return crc^0xffffffff;
}
uint32_t adler32(const uint8_t* d, size_t n) {
  uint32_t a=1,b=0,mod=65521;
  for(size_t i=0;i<n;i++) { a=(a+d[i])%mod; b=(b+a)%mod; }
  return (b<<16)|a;
}
uint8_t xor_checksum(const uint8_t* d, size_t n) {
  uint8_t s=0; for(size_t i=0;i<n;i++) s^=d[i]; return s;
}

#define CHACHA_KEY_LEN 32
#define CHACHA_IV_LEN 12
#define CHACHA_TAG_LEN 16
extern int chacha_poly_decrypt(uint8_t* out, size_t* outlen, const uint8_t* ciphertext, size_t ctlen,
  const uint8_t* key, const uint8_t* iv, const uint8_t* tag, const uint8_t* aad, size_t aadlen);
int chacha_decrypt(uint8_t* out, size_t* outlen, const uint8_t* ciphertext, size_t ctlen,
  const uint8_t* key, const uint8_t* iv, const uint8_t* tag, const uint8_t* aad, size_t aadlen) {
  return chacha_poly_decrypt(out, outlen, ciphertext, ctlen, key, iv, tag, aad, aadlen);
}

static const uint8_t opcode_action[256]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x12,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0xff,0x07,0xff,0xff,0xff,0xff,0xff,0x02,0xff,0xff,0x11,0xff,0xff,0xff,0xff,0xff,0xff,0x0d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0e,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x05,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x08,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0b,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0c,0xff,0x06,0xff,0xff,0x0a,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x04,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x09,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
int vm_run(uint8_t* buf, size_t buf_len, const uint8_t* actions, size_t actions_len, const uint8_t* key, size_t key_len) {
  if (!buf || !actions) return -1;
  static const char hex_ch[]="0123456789abcdef";
  for (size_t i = 0; i < actions_len; i++) {
    uint8_t idx = opcode_action[actions[i]];
    if (idx == 255) continue;
    switch (idx) {
      case 0: vm_apply(buf, buf_len); break;
      case 1: vm_apply_inv(buf, buf_len); break;
      case 2: if (key && key_len) { for (size_t j = 0; j < buf_len; j++) buf[j] ^= key[j % key_len]; } break;
      case 3: if (key && key_len) { for (size_t j = 0; j < buf_len; j++) buf[j] ^= key[j % key_len]; } break;
      case 4: if (buf_len >= 4) { uint32_t c = crc32(buf, buf_len - 4); write_u32be(c, buf + buf_len - 4); } break;
      case 5: if (buf_len >= 4) { uint32_t a = adler32(buf, buf_len - 4); write_u32be(a, buf + buf_len - 4); } break;
      case 6: if (buf_len >= 1) { uint8_t s = xor_checksum(buf, buf_len - 1); buf[buf_len - 1] = s; } break;
      case 7: if (buf_len >= 2 && (buf_len & 1) == 0) { size_t n = buf_len / 2; for (size_t k = n; k > 0;) { k--; uint8_t b = buf[k]; buf[2*k] = (uint8_t)hex_ch[b>>4]; buf[2*k+1] = (uint8_t)hex_ch[b&0xf]; } } break;
      case 8: if (buf_len >= 2 && (buf_len & 1) == 0) { size_t n = buf_len / 2; for (size_t k = 0; k < n; k++) { uint8_t a = hex_char((char)buf[2*k]), b = hex_char((char)buf[2*k+1]); if (a > 15 || b > 15) break; buf[k] = (uint8_t)(a<<4|b); } } break;
      case 9: for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32be(buf + k); write_u32le(v, buf + k); } break;
      case 10: for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32be(v, buf + k); } break;
      case 11: for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32be(v, buf + k); } break;
      case 12: for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32be(buf + k); write_u32le(v, buf + k); } break;
      case 13: if (key && key_len) { int r = key[0] & 31; for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32le(rotl32(v, r), buf + k); } } break;
      case 14: if (key && key_len) { int r = key[0] & 31; for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32le(rotr32(v, r), buf + k); } } break;
      case 15: for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32le(swap32(v), buf + k); } break;
      case 16: break;
      case 17: if (key && key_len >= 2) { int bi = key[0] & 31, on = key[1] & 1; for (size_t k = 0; k + 4 <= buf_len; k += 4) { uint32_t v = read_u32le(buf + k); write_u32le(set_bit(v, bi, on), buf + k); } } break;
      case 18: if (key && key_len >= 60 && buf_len > 16) { size_t outlen = 0; int rc = chacha_decrypt(buf, &outlen, buf, buf_len, key, key + 32, key + 44, (const uint8_t*)0, 0); if (rc != 0) return rc; } break;
      default: break;
    }
  }
  return 0;
}